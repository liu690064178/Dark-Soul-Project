# Dark-Soul-Project
1.逻辑层的类需要继承BomberUiLogicBase

2.表现层的类需要继承NGUIDesignerBase

```sequence
Title: 数据传递

网络层->网络层: 注册各种服务器消息委托
逻辑层->逻辑层: 添加ui资源
逻辑层->网络层: 注册方法到网络层的委托
逻辑层-->网络层: 请求数据
逻辑层->表现层: 打开UI界面
表现层->逻辑层: 持有逻辑对象

表现层->逻辑层: 注册本地方法到逻辑层的委托

网络层-->逻辑层: 数据响应，执行委托
逻辑层->表现层: 执行委托对服务器发来的数据进行更新

表现层 ->表现层: 刷新数据


```



- **ArrayList和List的区别**

1. 值类型：所谓的.net Framework中的“轻量类型”，为什么说是“轻量”呢，这和他的内存分配有直接关系，因为值类型是分配在栈上，所以在GC的控制之外，不会对GC造成压力。那是不是可以随便用呢？当然不是，举个例子：我自定义一个struct 类型作为一个方法的参数会发生什么呢？每次调用都会发生全字段的赋值，这是不可接受的，这也是典型的值类型勿用场景。
2. 引用类型：引用类型分配在堆中，所以会影响GC，如果频繁的初始化引用类型，对GC的压力是很大的，因为每一次分配都有可能会强制执行一次垃圾收集操作。另外提一点，引用类型的所占内存，并非所有属性/字段的和，堆上分配的每个对象都有一些额外的成员，这些成员必须初始化。（类型对象指针和内存块索引）。
3. 装箱拆箱：所谓装箱就是将值类型转化为引用类型的过程。拆箱则相反（只是概念上相反，实际编译器的操作不一样）。有的同学说装箱拆箱影响性能，那到底是装箱影响呢还是拆箱呢还是都影响呢？
   1. 装箱发生了什么过程呢：
      1. 在托管堆中分配好内存，分配的内存量是值类型的各个字段需要的内存量加上托管堆上所以对象的两个额外成员（类型对象指针，同步块索引）需要的内存量
      2. 值类型的字段复制到新分配的堆内存中
      3. 返回对象的地址，这个地址就是这个对象的引用
   2. 拆箱发生了什么过程呢：
      1. 获取已经装箱的值类型实例的指针
      2. 把获取到的值复制到栈

所以装箱是比较耗费性能的，还有可能引发一次GC操作，而拆箱只是一个获取指针的过程耗费资源要比装箱小的多。注意：**一个对象拆箱之后只能还原为原先未装箱之前的类型**，例如：你不能把int32类型装箱后还原为int16类型

- **向量的点乘和叉乘**

| 名称                                          | 标积/内积/数量积/点积                                 | 矢积/外积/向量积/叉积                                        |
| :-------------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- |
| 运算式（**a**，**b**和**c**粗体字，表示向量） | **a**·**b**=\|**a**\|\|**b**\|·cosθ                   | **a**×**b**=**c**，其中\|**c**\|=\|**a**\|\|**b**\|·sinθ，**c**的方向遵守右手定则 |
| 几何意义                                      | 向量**a**在向量**b**方向上的投影与向量**b**的模的乘积 | **c**是垂直a、b所在平面，且以\|**b**\|·sinθ为高、\|**a**\|为底的平行四边形的面积 |
| 运算结果的区别                                | 标量（常用于物理）/数量（常用于数学）                 | 矢量（常用于物理）/向量（常用于数学）                        |

- **什么时内存泄漏，如何避免**

  内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

- **什么是线程的同步和互斥**

1. 互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
2. 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
3. 同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。
4. 互斥是一种特殊的同步

- **prefab的优点，在移动设备如何恰当的使用**

  Prefab在实例化的时候用到，主要用于经常会用到的物体，属性方便修改

- **什么是Unity3d协程，和C#的线程有什么区别？主要用来解决什么问题？举例**

- **光照计算diffuse**


  $$ {Kd 漫反射系数 .}
  diffuse = Kd * colorLight * max(N * L, 0)\\
  Kd 漫反射系数 \\
  colorLight 光的颜色 \\
  N 单位法线向量 \\
  L 由点指向光源的单位向量 \\
  其中N与L点乘，如果结果小于等于0，则漫反射为0\\
  $$

- **如何使用两个栈维护一个 队列**

  首先定义两个栈 StackIn和StackOut   入队时压入StackIn  如果出队先检查StackOut是否为空，

  如果为空 则让StackIn的栈元素依次出栈再依次压入StackOut，这样最后StackOut栈元素就符合了队列FIFO的特性了 

- **欧拉角和四元数的区别**

- **A*算法的实现原理**

- **简述渲染管线**

- **使用过什么插件，列出你自己编写的插件及其技术点** 

  advanced Inspector

  

  

- **旋转矩阵**

$$
绕x轴旋转
\begin{matrix}
	1 & 0 & 0 & 0\\
	0 & cos\theta & sin\theta & 0\\
	0 & -sin\theta & cos\theta & 0\\
	0 & 0 & 0 & 1\\
	\end{matrix}
$$



- **二分查找**

  ```C#
          /// <summary>
          /// 二分查找
          /// </summary>
          /// <param name="a">排好序的数组</param>
          /// <param name="key">要查找的</param>
          /// <returns>返回下标 -1无结果</returns>
          private static int MyBinarySearch(int[] a, int key)
          {
  
              int max = a.Length - 1;
              Console.WriteLine(a.Length);
              int min = 0;
              int mid = min;
              while (min <= max)
              {
                  // mid = min + (max - min) / 2;
                  mid = (min + max) >> 1;
                  if (key < a[mid])
                  {
                      max = mid - 1;
                  }
                  else if (key > a[mid])
                  {
                      min = mid + 1;
                  }
                  else
                  {
                      return mid;
                  }
              }
  
              return -1;
  
          }
  ```

- **快速排序**

```C#
        public static void MyQuickSort(int[] a, int left, int right)
        {
            if (left > right)
                return;

            int key = a[left];

            int i = left;
            int j = right;
            int temp = 0;


            while (i != j)
            {
                while (a[j] >= key && i < j)
                {
                    j--;
                }
                while (a[i] <= key && i < j)
                {
                    i++;
                }

                if (i < j)
                {
                    temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                }
            }

            a[left] = a[i];
            a[i] = key;

            MyQuickSort(a, left, i - 1);
            MyQuickSort(a, i + 1, right);
        }
```

- **角度归一化**

  ```c#
   		/// <summary>
          /// 角度归一化
          /// </summary>
          /// <param name="angle">待转换角度</param>
          /// <returns>归一化的角度</returns>
          private static double NormalizeDegree(double angle)
          {
              int angleD = (int)angle;
              double n = angleD % 360 + (angle - angleD);
              return n > 0 ? n : 360 + n;
          }
  ```

  
